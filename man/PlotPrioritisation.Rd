% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PlotPrioritisation.R
\name{PlotPrioritisation}
\alias{PlotPrioritisation}
\alias{getPlotPrior}
\alias{getPlotPrior.JostDiver}
\alias{getPlotPrior.PhyloAlpha}
\alias{mergePlotPriorListOfDF}
\alias{plotPrioritisation}
\alias{plotPrioritisation.Attribute}
\title{Plot prioritisation}
\usage{
getPlotPrior.JostDiver(t.community.matrix, lev = c("alpha", "beta", "gamma"),
  q = 1, order.by = c("sample", "rank", "diversity"))

getPlotPrior.PhyloAlpha(t.community.matrix, phylo.tree, taxa.match = TRUE,
  order.by = c("sample", "rank", "diversity"), ...)

getPlotPrior(cm.list, is.transposed = FALSE, tre.list = list(),
  taxa.match = TRUE, diversities = c("gamma0", "gamma1", "beta0", "beta1",
  "pd.alpha", "sp.rich"))

mergePlotPriorListOfDF(plot.prior.list, suffixes = c(), rm.prefix = TRUE)

plotPrioritisation(pp.df.list, at = c("rank", "diversity"),
  guide = "colourbar", x.levels = c(), y.levels = c(),
  add.label = FALSE, label.digits = 1, ...)

plotPrioritisation.Attribute(pp.df, attr.df, y2.id = "Elevation",
  y2.lab = "Elevation (m)", x.lab = "", y.lab = "", grid.widths = c(8,
  3), ...)
}
\arguments{
\item{t.community.matrix}{A transposed matrix from community matrix, 
where rows are plots (Use plots instead of subplots.), columns are OTUs.}

\item{lev}{Level of diversity to be calculated. 
Will accept: 'alpha', 'beta', or 'gamma'.}

\item{q}{Order of the diversity measure. 
Defaults to the Shannon case where q = 1.}

\item{order.by}{How the result is ordered. 
Choose from 'sample', 'rank', or 'diversity'.}

\item{phylo.tree, ...}{The parameters passed to \code{\link{phylo.alpha}}.}

\item{taxa.match}{Logical, if taxa in phylogenies do not match OTUs in the community. 
If TRUE, as default, to use t.community.matrix and phylo.tree directly, 
otherwise to call \code{\link{match.phylo.comm}} 
before calculate phylogenetic alpha diversity.}

\item{cm.list}{The list of community matrices.}

\item{is.transposed}{If TRUE, then the community matrix is already
transposed to be the valid input of \code{\link{vegdist}}.  
Default to FASLE to transpose.}

\item{tre.list}{A list of phylo tree objects for 'pd.alpha' and 'sp.rich',
corresponding to \code{cm.list}. Default to an empty list.}

\item{diversities}{The vector of diversities used to compute plot prioritisation.
The values are 'gamma0','gamma1','beta0','beta1','pd.alpha','sp.rich'. 
The first two are calculated by \code{\link{d}}, 
the last two by \code{\link{pd}}.}

\item{plot.prior.list}{The output from \code{getPlotPrior}.}

\item{suffixes}{The vector of suffixes added to distinguish colmun names 
merged by different data frames. Its length must equal to \code{plot.prior.list}.}

\item{pp.df.list}{The output from \code{mergePlotPriorListOfDF}.}

\item{at}{The values of heatmap, choose from "rank" or "diversity".}

\item{pp.df}{One element of the 'rank' list from \code{mergePlotPriorListOfDF}.}

\item{attr.df}{Environmental meta-data. Rows are samples, 
and must include all rownames from \code{pp.df}}

\item{y2.id, y2.lab}{The column of \code{attr.df} used 
to plot the 2nd figure on the right side, default to "Elevation".}

\item{grid.widths}{A unit vector giving the width of each two columns,
used by \code{\link{grid.arrange}} and default to \code{c(8, 3)}.}

\item{row.id}{What row names are representing.}
}
\value{
A data frame with 2 columns: \emph{rank, diversity}. 
Rank 1 is the most important plot, 
\emph{n} is the least important, and row.names are plot names. 
For example,
\tabular{rrr}{
   \tab rank \tab diversity\cr
  CM30c39 \tab 28 \tab 1845.785714\cr
  CM30c44 \tab 27 \tab 1875.888889\cr
  CM31a5 \tab 26 \tab 1899.653846 
}
}
\description{
Ranking of sample plots by their contributions 
to the total biodiversity.
}
\details{
\code{getPlotPrior.JostDiver} computes plot prioritisation 
by Jost diversity calculated from \pkg{vegetarian} \code{\link{d}}.
It uses a greedy algorithm to remove plots sequentially 
so as to minimize the loss of diversity among the remaining plots,
which always chooses the 1st plot if there are multi-results 
in each prioritisation loop.
Rank 1 is the most important plot and removed at the last, 
\emph{n} is the least important and removed in the beginning.

\code{getPlotPrior.PhyloAlpha} calculates plot prioritisation 
by phylogenetic alpha diversity from \code{\link{phylo.alpha}}.
It also can return the ranks based on species richness (SR), 
but they may be different to ranks calculated from 
\code{getPlotPrior.JostDiver} using gamma0 (also species richness).

\code{getPlotPrior} is a generic function including both 
\code{getPlotPrior.JostDiver} and \code{getPlotPrior.PhyloAlpha}, 
and it also handles multiple communities.

\code{mergePlotPriorListOfDF} merges a list of data frames  
produced by \code{getPlotPrior} into one. Their columns must contain
'rank' and 'diversity'.

\code{plotPrioritisation} produces the list of \code{\link{ggHeatmap}}
given a list of output from \code{mergePlotPriorListOfDF}.

\code{plotPrioritisation.Attribute} produces 
one clusterd heatmap using \code{\link{NeatMap}} 
and attaches an additional plot of a selected attribute  
from environmental meta-data, such as Elevation.
}
\examples{
plot.prior.g1 <- getPlotPrior.JostDiver(t.community.matrix, lev="gamma", q=1)

phylo.alpha <- getPlotPrior.PhyloAlpha(t.community.matrix, phylo.tree)

plot.prior.list <- getPlotPrior(cm.list, is.transposed=FALSE, diversities=c("gamma1","beta1"))
plot.prior.list <- getPlotPrior(cm.list, is.transposed=FALSE, tre.list=tre.list, diversities=c("gamma1","beta1","pd.alpha","sp.rich"))
pp.df.list <- mergePlotPriorListOfDF(plot.prior.list)

heatmap.list <- plotPrioritisation(pp.df.list, add.label=T)

hm.elv <- plotPrioritisation.Attribute(pp.df.list[["rank"]][[1]], env.plot, grid.widths = c(10,2))
plot(hm.elv$heatmap)

}
\keyword{plot}
\keyword{prioritisation}

