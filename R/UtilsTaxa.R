# Author: Walter Xie
# Accessed on 11 Apr 2016

#' @name utilsTaxa
#' @title Utils to preprocess taxa table
#'
#' @description Utils to preprocess taxa table, 
#' and make it easy for visualization.
#' 
#' @details 
#' \code{subsetTaxaTable} takes or excludes a subset of given a taxa table at given rank.
#' 
#' @param taxa.table A data frame to contain taxonomic classifications of OTUs. 
#' Columns are taxonomy at the rank or lineage, rows are OTUs which need to 
#' match rows from community matrix. Use \code{\link{readTaxaTable}} to get it from file.
#' @param taxa.group The taxonomic group, the values can be 'all', 'assigned', or 
#' Group 'all' includes everything.
#' Group 'assigned' removes all uncertain classifications including 
#' 'root', 'cellular organisms', 'No hits', 'Not assigned'. 
#' Alternatively, any high-ranking taxonomy in your taxonomy file 
#' can be used as a group or multi-groups (seperated by "|"), 
#' such as 'BACTERIA', 'Proteobacteria', etc. But they have to be 
#' in the same rank column in the file. Default to remove all 
#' uncertain classifications, even when group(s) assigned.
#' @param rank The rank to specify which column name in \code{taxa.table} to search. 
#' @param include Define whether include or exclude given \code{taxa.group}. 
#' Default to TRUE.
#' @param verbose More details. Default to TRUE.
#' @keywords utils
#' @export
#' @examples 
#' tt.sub <- subsetTaxaTable(tt.megan, taxa.group="Proteobacteria", rank="phylum")
#' tt.sub <- subsetTaxaTable(tt.megan, taxa.group="Cnidaria|Brachiopoda|Echinodermata|Porifera", rank="phylum", include=FALSE)
#' 
#' @rdname utilsTaxa
subsetTaxaTable <- function(taxa.table, taxa.group="assigned", rank="kingdom", include=TRUE, verbose=TRUE) {
  if (include) {
    # include PROTISTS, taxa.group="CHROMISTA|PROTOZOA", rank="kingdom"
    taxa.table <- subset(taxa.table, (grepl(taxa.group, taxa.table[,rank], ignore.case = T))) 
  } else { 
    # exclude some phyla, taxa.group="Cnidaria|Brachiopoda|Echinodermata|Porifera", rank="phylum"
    taxa.table <- subset(taxa.table, !grepl(taxa.group, taxa.table[,rank], ignore.case = T)) 
  }
  return(taxa.table)
}


#' @details 
#' \code{mergeCMTaxa} creates a data frame \code{cm.taxa} combined community matrix with 
#' taxonomic classification table. The 1st column is "row.names" that are OTUs/individuals, 
#' the next "ncol.cm" columns are abundence that can be sample-based or total, 
#' and the last "length(col.ranks)" columns are the ranks. 
#' 
#' All sequences either classified as 
#' "root|cellular organisms|No hits|Not assigned|unclassified sequences"
#' from BLAST + MEGAN, or confidence < \emph{min.conf} threshold from RDP, 
#' are changed to "unclassified", which will be moved to the last row.  
#' 
#' @param community.matrix Community matrix (OTU table), where rows are 
#' OTUs or individual species and columns are sites or samples. See \code{\link{ComMA}}.
#' @param classifier The classifier is used to generate \code{taxa.table}. 
#' Value is MEGAN or RDP. Default to MEGAN.
#' @param min.conf The confidence threshold to drop rows < \emph{min.conf}.
#' @param has.total If 0, then only return abudence by samples (columns) of community matrix. 
#' If 1, then only return toal abudence. If 2, then return abudence by samples (columns) and total. 
#' Default to 1.
#' @param col.ranks A vector or string of column name(s) of taxonomic ranks in the taxa table, 
#' which will determine the aggregated abundence matrix. They have to be full set or subset of 
#' c("superkingdom", "kingdom", "phylum", "class", "order", "family", "genus", "species"). 
#' Default to c("kingdom", "phylum", "class", "order", "family", "genus").
#' @param sort Sort the taxonomy rank by rank. Default to TRUE.
#' @return 
#' \code{ncol.cm} and \code{col.ranks} are attributes of \code{cm.taxa} generated by \code{mergeCMTaxa}.
#' 
#' \code{ncol.cm} indicates how many column(s) is/are abundence in \code{cm.taxa}.
#'
#' \code{col.ranks} records what ranks column(s) is/are in \code{cm.taxa}, 
#' which is also the input of \code{mergeCMTaxa}. 
#' 
#' @keywords utils
#' @export
#' @rdname utilsTaxa
mergeCMTaxa <- function(community.matrix, taxa.table, classifier="MEGAN", min.conf=0.8, 
                        has.total=1, sort=TRUE,
                        col.ranks=c("kingdom", "phylum", "class", "order", "family", "genus")) {
  ranks <- getRanks()
  if (length(col.ranks) < 1 || !all(col.ranks %in% ranks)) 
    stop(cat("Invaild column names for ranks !\nUse one element or a subset of", 
             paste(ranks, collapse = ",")))
  if (!all(col.ranks %in% colnames(taxa.table))) 
    stop(cat("Column names in taxa.table do not have", 
             paste(col.ranks, collapse = ",")))
  if ("confidence" %in% colnames(taxa.table) && classifier != "RDP")
    stop("Find 'confidence' column, please define classifier = 'RDP' !")
  
  ###### merge community.matrix, taxa.table 
  cm <- data.frame(row.names = rownames(community.matrix))
  if (has.total!=1) 
    cm <- community.matrix
  if (has.total > 0) 
    cm[,"total"] <- rowSums(community.matrix) 
  ncol.cm <- ncol(cm)
  
  if (classifier == "RDP") {
    if (! "confidence" %in% colnames(taxa.table))
      stop("Invaild file format from RDP: column 'confidence' is required !")
    
    ### drop rows < min.conf
    n.row.un <- nrow(taxa.table[taxa.table[,"confidence"] < min.conf, ])
    taxa.table[taxa.table[,"confidence"] < min.conf, col.ranks] <- "unclassified"
    
    cat("Set", n.row.un, "rows as unclassified from the total of", nrow(taxa.table), 
        "in RDP taxa table, whose confidence <", min.conf, ".\n")
  } else {
    # BLAST + MEGAN
    for (ra in col.ranks) {
      id.match <- grep("root|cellular organisms|No hits|Not assigned|unclassified sequences", 
                       taxa.table[, ra], ignore.case = TRUE)
      if (length(id.match) > 0)
        taxa.table[id.match, ra] <- paste("unclassified")
    }
  }
  
  # cm.taxa 1st col is "row.names", "ncol.cm" columns abundence, and length(col.ranks) columns rank
  cm.taxa <- merge(cm, taxa.table, by = "row.names")
  
  if (sort) {
    # order rank by rank
    ord.cmd = parse(text = paste0('cm.taxa[order(cm.taxa[,"', paste(col.ranks, collapse = '"], cm.taxa[,"'), '"]),]')) 
    cm.taxa <- eval(ord.cmd)
  }
  
  cat("Merge", nrow(cm), "rows in community matrix with", nrow(taxa.table), "rows in taxa table, get", 
      nrow(cm.taxa), "classifications.\n")
  
  attr(cm.taxa, "ncol.cm") <- ncol.cm
  attr(cm.taxa, "col.ranks") <- col.ranks
  return(cm.taxa)
}

#' @details 
#' \code{assignTaxa} provides a list of taxonomic assignments with abudence 
#' from community matrix at different rank levels, where rownames are taxonomy 
#' at that rank, and columns are the sample names (may include total). 
#' The function is iterated through \code{col.ranks}, and \code{\link{aggregate}}s 
#' abudence into taxonomy based on the rank in \code{col.ranks}. 
#' 
#' @param cm.taxa The data frame combined community matrix with 
#' taxonomic classifications generated by \code{mergeCMTaxa} (\code{\link{merge}}).
#' The 1st column is "row.names", \code{ncol.samples} columns 
#' abundence, and \code{length(col.ranks)} columns taxonomy 
#' at different ranks. 
#' It should also have attributes \code{ncol.cm} and \code{col.ranks}.
#' @param unclassified An interger to instruct how to deal with 
#' "unclassified" taxa. Default to 0, which keeps all "unclassified"
#' but moves them to the last rows. 
#' If 1, then remove the row whose taxon name is exact "unclassified". 
#' See the detail. 
#' If 2, then remove the row whose taxon name is exact "unclassified", 
#' but also merge all the rest "unclassified ???" to "unclassified rank",
#' such as "unclassified family".
#' If 3, then remove every rows containing "unclassified".
#' @param aggre.FUN A function for \code{FUN} in \code{\link{aggregate}}. 
#' Default to \code{sum} to provide the reads abundance. 
#' Make \code{aggre.FUN=function(x) sum(x>0)} provide the OTU abundance.
#' @keywords utils
#' @export
#' @examples 
#' cm.taxa <- mergeCMTaxa(community.matrix, tt.megan) 
#' ta.megan <- assignTaxaByRank(cm.taxa)
#' 
#' cm.taxa <- mergeCMTaxa(community.matrix, tt.rdp, classifier="RDP", has.total=0)
#' ta.rdp <- assignTaxaByRank(cm.taxa, unclassified=2)
#' colSums(ta.rdp[["phylum"]])
#' 
#' @rdname utilsTaxa
assignTaxaByRank <- function(cm.taxa, unclassified=0, aggre.FUN=sum) {
  attr.cm.ta <- attributes(cm.taxa)
  ncol.cm <- attr.cm.ta$ncol.cm
  col.ranks <- attr.cm.ta$col.ranks
  
  if (is.null(ncol.cm) || is.null(col.ranks)) 
    stop("Input cm.taxa should have attributes ncol.cm and col.ranks !")
  
  ###### aggregate by ranks
  ta.list <- list()
  pre.ra <- NA
  for (ra in col.ranks) {
    ra.col=which(colnames(cm.taxa)==ra)
    
    ### preprocess rank columns
    if (length(ta.list) > 0) {
      # replace repeated high rank taxa to unclassified high rank
      # MEGAN unclassified
      id.match <- intersect(!grep("unclassified", cm.taxa[, pre.ra.col], ignore.case = T), 
                            which(cm.taxa[, pre.ra.col]==cm.taxa[, ra.col]))
      # MEGAN environmental samples
      id.match <- c(id.match, grep("environmental samples", cm.taxa[, ra.col], ignore.case = T))
      # RDP unclassified
      id.match <- c(id.match, which(trimAll(cm.taxa[, ra.col])==""))
      if (length(id.match) > 0)
        cm.taxa[id.match, ra.col] <- paste("unclassified", cm.taxa[id.match, pre.ra.col])
      
      # replace unclassified ??? to unclassified high rank
      id.match <- grep("unclassified ", cm.taxa[, pre.ra.col], ignore.case = TRUE)
      if (length(id.match) > 0)
        cm.taxa[id.match, ra.col] <- paste("unclassified", pre.ra)
    }
    
    ### aggregate
    # cm.taxa 1st col is "row.names", "ncol.samples" columns abundence, and length(col.ranks) columns rank
    data.ta <- cm.taxa[,c(2:(1+ncol.cm), ra.col)]
    # e.g. family plot1 plot2 ...
    taxa.assign <- aggregate(as.formula(paste(". ~", ra)), data=data.ta, FUN=aggre.FUN)
    
    # deal with "unclassified"
    if (unclassified==0) {
      # move "unclassified ???" to last
      taxa.assign <- ComMA::mvRowsToLast(taxa.assign, ra, "unclassified")
      # move "unclassified phylum" to last
      if (!is.na(pre.ra)) 
        taxa.assign <- ComMA::mvRowsToLast(taxa.assign, ra, paste0("^unclassified ", pre.ra, "$"))
      # move "unclassified" to last
      taxa.assign <- ComMA::mvRowsToLast(taxa.assign, ra, "^unclassified$")
    } else if (unclassified==1) {
      taxa.assign <- subset(taxa.assign, !grepl("^unclassified$", taxa.assign[, ra], ignore.case = T))
    } else if (unclassified==2) {
      ta.tmp <- subset(taxa.assign, !grepl("unclassified", taxa.assign[, ra], ignore.case = T))
      ta.un.tmp <- subset(taxa.assign, grepl("unclassified", taxa.assign[, ra], ignore.case = T))
      ta.un.tmp <- subset(ta.un.tmp, !grepl("^unclassified$", ta.un.tmp[, ra], ignore.case = T))
      if (nrow(ta.un.tmp) > 0) {
        # rank + colnames(cm)
        if (ncol(ta.un.tmp) != ncol.cm + 1)
          stop(cat("Invalid index, unclassified =", unclassified, ", where ncol", 
                   ncol(ta.un.tmp), "should ==", ncol.cm + 1, "!"))
        
        if (ncol(ta.un.tmp) > 2)
          ra.un <- c(paste("unclassified", ra), colSums(ta.un.tmp[,-1]))
        else
          ra.un <- c(paste("unclassified", ra), sum(ta.un.tmp[,-1]))
        ta.tmp <- rbind(ta.tmp, ra.un)
      }
      taxa.assign <- ta.tmp
      taxa.assign[,2:ncol(taxa.assign)] <- sapply(taxa.assign[,2:ncol(taxa.assign)], as.numeric)
    } else {
      taxa.assign <- subset(taxa.assign, !grepl("unclassified", taxa.assign[, ra], ignore.case = T))
    }
    # move taxa to rownames
    rownames(taxa.assign) <- taxa.assign[,1]
    taxa.assign <- taxa.assign[,-1]
    # add rank attr
    attr(taxa.assign, "rank") <- ra
    
    ta.list[[ra]] <- taxa.assign
    pre.ra.col <- ra.col
    pre.ra <- ra
  }
  return(ta.list)
}

#' @details 
#' \code{groupsTaxaMembers} groups the members (rows, also OTUs) from 
#' \code{cm.taxa} for each taxa in \code{taxa.assign} at the \code{rank}, 
#' and returns a list of members (OTUs) grouped by taxonomy. 
#' Default to drop all unclassified members (OTUs). 
#' 
#' It is impossible to trace back members after \code{assignTaxaByRank},
#' so that this function only has one option except the default, 
#' which assign the rest of members (OTUs) not picked up from other taxa  
#' into "unclassified". The result relies on using the identical \code{cm.taxa} 
#' in both \code{assignTaxaByRank} and \code{groupsTaxaMembers}.
#' 
#' @param taxa.assign The data frame of taxonomic assignments with abudence
#' at the \code{rank}, where rownames are taxonomy at that rank, 
#' and columns are the sample names (may include total). It can be 
#' one element of the list generated by \code{assignTaxaByRank}. 
#' See the detail.
#' @param regex1,regex2 Use for \code{\link{gsub}(regex1, regex2, row.names)} 
#' to remove or replace annotation from original labels. 
#' Default to \code{regex1="(\\|[0-9]+)", regex2=""}, 
#' which removes size annotation seperated by "|".
#' @param rm.unclassified Drop all unclassified rows (OTUs). Default to TRUE.
#' @keywords utils
#' @export
#' @examples 
#' taxa.members <- groupsTaxaMembers(ta.rdp[["phylum"]], tt.rdp)
#' taxa.members <- groupsTaxaMembers(ta.rdp[["family"]], tt.rdp, rank="family")
#' 
#' @rdname utilsTaxa
groupsTaxaMembers <- function(taxa.assign, cm.taxa, rank="phylum", rm.unclassified=TRUE,
                              regex1="(\\|[0-9]+)", regex2="", ignore.case=TRUE) {
  if (!is.element("Row.names", colnames(cm.taxa)))
    stop("Invalid cm.taxa, which needs the column \"Row.names\" !")
  rownames(cm.taxa) <- cm.taxa[,"Row.names"]
  if (is.null(rownames(taxa.assign)) || is.null(rownames(cm.taxa)))
    stop("Invalid taxa.assign or cm.taxa, which needs taxa or OTUs in its rownames !")
  ra <- attributes(taxa.assign)$rank
  if (is.null(ra))
    warning("Cannot find rank attribute from taxa.assign, no validation is proceeded !")
  else if (ra != rank)
    stop("Inconsistent rank level for taxa.assign : ", ra, " != ", rank, " !")
  
  id.unclassified <- grep("unclassified", rownames(taxa.assign), ignore.case = T)
  if (length(id.unclassified) > 0) {
    if (rm.unclassified)
      warning("Drop all unclassified rows (OTUs) belonging to : ", 
              paste(rownames(taxa.assign)[id.unclassified], collapse = ","), " !\n")
    
    taxa.assign <- taxa.assign[-id.unclassified,]
  }
  
  # remove/replace annotation
  if (! is.null(regex1)) 
    rownames(cm.taxa) <- gsub(regex1, regex2, rownames(cm.taxa), ignore.case = ignore.case)
  
  taxa.members <- sapply(rownames(taxa.assign), 
                         function(taxa) rownames(cm.taxa)[which(cm.taxa[,rank] == taxa)])
  
  # add the rest of OTUs into unclassified
  if (!rm.unclassified && length(id.unclassified) > 0) {
    uncl.members <- setdiff(rownames(cm.taxa), unlist(taxa.members)) 
    taxa.members[["unclassified"]] <- uncl.members
    cat("Add", length(uncl.members), "OTUs into unclassified.\n")
  }
  
  if (!all(lapply(taxa.members,length)>0)) {
    warning("Remove taxa having no OTU : ", 
            paste(names(taxa.members)[lapply(taxa.members,length)<=0], collapse = ","), " !\n")
    # Remove empty elements from list
    taxa.members <- taxa.members[lapply(taxa.members,length)>0]
  }
  
  return(taxa.members)
}

# taxonomic ranks for column names
getRanks <- function() {
  ranks <- c("superkingdom", "kingdom", "phylum", "class", "order", "family", "genus", "species")
}

