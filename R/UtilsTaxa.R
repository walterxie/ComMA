# Author: Walter Xie
# Accessed on 11 Apr 2016

#' @name utilsTaxa
#' @title Utils to preprocess taxa table
#'
#' @description Utils to preprocess taxa table, 
#' and make it easy for visualization.
#' 
#' @details 
#' \code{subsetTaxaTable} takes or excludes a subset of given a taxa table at given rank.
#' 
#' @param taxa.table A data frame to contain taxonomic classifications of OTUs. 
#' Columns are taxonomy at the rank or lineage, rows are OTUs which need to 
#' match rows from community matrix. Use \code{\link{readTaxaTable}} to get it from file.
#' @param taxa.group The taxonomic group, the values can be 'all', 'assigned', or 
#' Group 'all' includes everything.
#' Group 'assigned' removes all uncertain classifications including 
#' 'root', 'cellular organisms', 'No hits', 'Not assigned'. 
#' Alternatively, any high-ranking taxonomy in your taxonomy file 
#' can be used as a group or multi-groups (seperated by "|"), 
#' such as 'BACTERIA', 'Proteobacteria', etc. But they have to be 
#' in the same rank column in the file. Default to remove all 
#' uncertain classifications, even when group(s) assigned.
#' @param rank The rank column in the file to specify where to 
#' search for \code{taxa.group}. 
#' @param include Define whether include or exclude given \code{taxa.group}. 
#' Default to TRUE.
#' @param verbose More details. Default to TRUE.
#' @keywords utils
#' @export
#' @examples 
#' tt.sub <- subsetTaxaTable(tt.megan, taxa.group="Proteobacteria", rank="phylum")
#' tt.sub <- subsetTaxaTable(tt.megan, taxa.group="Cnidaria|Brachiopoda|Echinodermata|Porifera", rank="phylum", include=FALSE)
#' 
#' @rdname utilsTaxa
subsetTaxaTable <- function(taxa.table, taxa.group="assigned", rank="kingdom", include=TRUE, verbose=TRUE) {
  if (include) {
    # include PROTISTS, taxa.group="CHROMISTA|PROTOZOA", rank="kingdom"
    taxa.table <- subset(taxa.table, (grepl(taxa.group, taxa.table[,rank], ignore.case = T))) 
  } else { 
    # exclude some phyla, taxa.group="Cnidaria|Brachiopoda|Echinodermata|Porifera", rank="phylum"
    taxa.table <- subset(taxa.table, !grepl(taxa.group, taxa.table[,rank], ignore.case = T)) 
  }
  return(taxa.table)
}


#' @details 
#' \code{mergeCMTaxa} creates a data frame \code{cm.taxa} combined community matrix with 
#' taxonomic classification table. The 1st column is "row.names" that are OTUs/individuals, 
#' the next "ncol.cm" columns are abundence that can be sample-based or total, 
#' and the last "length(col.ranks)" columns are the ranks. 
#' 
#' All sequences either classified as 
#' "root|cellular organisms|No hits|Not assigned|unclassified sequences"
#' from BLAST + MEGAN, or confidence < \emph{min.conf} threshold from RDP, 
#' are changed to "unclassified", which will be moved to the last row.  
#' 
#' @param community.matrix Community matrix (OTU table), where rows are 
#' OTUs or individual species and columns are sites or samples. See \code{\link{ComMA}}.
#' @param classifier The classifier is used to generate \code{taxa.table}. 
#' Value is MEGAN or RDP. Default to MEGAN.
#' @param min.conf The confidence threshold to drop rows < \emph{min.conf}.
#' @param has.total If 0, then only return abudence by samples (columns) of community matrix. 
#' If 1, then only return toal abudence. If 2, then return abudence by samples (columns) and total. 
#' Default to 1.
#' @param col.ranks A vector or string of column name(s) of taxonomic ranks in the taxa table, 
#' which will determine the aggregated abundence matrix. They have to be full set or subset of 
#' c("superkingdom", "kingdom", "phylum", "class", "order", "family", "genus", "species"). 
#' Default to c("kingdom", "phylum", "class", "order", "family", "genus").
#' @param sort Sort the taxonomy rank by rank. Default to TRUE.
#' @return 
#' \code{ncol.cm} and \code{col.ranks} are attributes of \code{cm.taxa} generated by \code{mergeCMTaxa}.
#' 
#' \code{ncol.cm} indicates how many column(s) is/are abundence in \code{cm.taxa}.
#'
#' \code{col.ranks} records what ranks column(s) is/are in \code{cm.taxa}, 
#' which is also the input of \code{mergeCMTaxa}. 
#' 
#' @keywords utils
#' @export
#' @rdname utilsTaxa
mergeCMTaxa <- function(community.matrix, taxa.table, classifier="MEGAN", min.conf=0.8, has.total=1,
                             col.ranks=c("kingdom", "phylum", "class", "order", "family", "genus"), sort=TRUE) {
  ranks <- getRanks()
  if (length(col.ranks) < 1 || !all(col.ranks %in% ranks)) 
    stop(cat("Invaild column names for ranks !\nUse one element or a subset of", 
             paste(ranks, collapse = ",")))
  if (!all(col.ranks %in% colnames(taxa.table))) 
    stop(cat("Column names in taxa.table do not have", 
             paste(col.ranks, collapse = ",")))
  if ("confidence" %in% colnames(taxa.table) && classifier != "RDP")
    stop("Find 'confidence' column, please define classifier = 'RDP' !")
  
  ###### merge community.matrix, taxa.table 
  cm <- data.frame(row.names = rownames(community.matrix))
  if (has.total!=1) 
    cm <- community.matrix
  if (has.total > 0) 
    cm$Total <- rowSums(community.matrix) 
  ncol.cm <- ncol(cm)
  
  if (classifier == "RDP") {
    if (! "confidence" %in% colnames(taxa.table))
      stop("Invaild file format from RDP: column 'confidence' is required !")
    
    ### drop rows < min.conf
    n.row.un <- nrow(taxa.table[taxa.table[,"confidence"] < min.conf, ])
    taxa.table[taxa.table[,"confidence"] < min.conf, col.ranks] <- "unclassified"
    
    cat("Set", n.row.un, "rows as unclassified from the total of", nrow(taxa.table), 
        "in RDP taxa table, whose confidence <", min.conf, ".\n")
  } else {
    # BLAST + MEGAN
    for (ra in col.ranks) {
      id.match <- grep("root|cellular organisms|No hits|Not assigned|unclassified sequences", 
                       taxa.table[, ra], ignore.case = TRUE)
      if (length(id.match) > 0)
        taxa.table[id.match, ra] <- paste("unclassified")
    }
  }
  
  # cm.taxa 1st col is "row.names", "ncol.cm" columns abundence, and length(col.ranks) columns rank
  cm.taxa <- merge(cm, taxa.table, by = "row.names")
  
  if (sort) {
    # order rank by rank
    ord.cmd = parse(text = paste0('cm.taxa[order(cm.taxa[,"', paste(col.ranks, collapse = '"], cm.taxa[,"'), '"]),]')) 
    cm.taxa <- eval(ord.cmd)
  }
  
  cat("Merge", nrow(cm), "rows in community matrix with", nrow(taxa.table), "rows in taxa table, get", 
      nrow(cm.taxa), "classifications.\n")
  
  attr(cm.taxa, "ncol.cm") <- ncol.cm
  attr(cm.taxa, "col.ranks") <- col.ranks
  return(cm.taxa)
}

#' @details 
#' \code{assignTaxa} provides a list of taxonomic assignments with abudence 
#' from community matrix at different rank levels. The function is iterated 
#' through \code{col.ranks}, and \code{\link{aggregate}}s abudence into 
#' taxonomy based on the rank in \code{col.ranks}. 
#' 
#' @param cm.taxa The data frame combined community matrix with 
#' taxonomic classifications generated by \code{mergeCMTaxa}. It 
#' should have attributes \code{ncol.cm} and \code{col.ranks}.
#' @keywords utils
#' @export
#' @examples 
#' cm.taxa <- mergeCMTaxa(community.matrix, tt.megan) 
#' ta.megan <- assignTaxaByRank(cm.taxa)
#' 
#' cm.taxa <- mergeCMTaxa(community.matrix, tt.rdp, col.ranks="kingdom", classifier="RDP")
#' ta.rdp <- assignTaxaByRank(cm.taxa)
#' 
#' @rdname utilsTaxa
assignTaxaByRank <- function(cm.taxa) {
  attr.cm.ta <- attributes(cm.taxa)
  ncol.cm <- attr.cm.ta$ncol.cm
  col.ranks <- attr.cm.ta$col.ranks
  
  if (is.null(ncol.cm) || is.null(col.ranks)) 
    stop("Input cm.taxa should have attributes ncol.cm and col.ranks !")
    
  ###### aggregate by ranks
  ta.list <- list()
  pre.ra <- NA
  for (ra in col.ranks) {
    ra.col=which(colnames(cm.taxa)==ra)
    
    ### preprocess rank columns
    if (length(ta.list) > 0) {
      # replace repeated high rank taxa to unclassified high rank
      # MEGAN unclassified
      id.match <- intersect(!grep("unclassified", cm.taxa[, pre.ra.col], ignore.case = T), 
                            which(cm.taxa[, pre.ra.col]==cm.taxa[, ra.col]))
      # MEGAN environmental samples
      id.match <- c(id.match, grep("environmental samples", cm.taxa[, ra.col], ignore.case = T))
      # RDP unclassified
      id.match <- c(id.match, which(trimAll(cm.taxa[, ra.col])==""))
      if (length(id.match) > 0)
        cm.taxa[id.match, ra.col] <- paste("unclassified", cm.taxa[id.match, pre.ra.col])
      
      # replace unclassified ??? to unclassified high rank
      id.match <- grep("unclassified ", cm.taxa[, pre.ra.col], ignore.case = TRUE)
      if (length(id.match) > 0)
        cm.taxa[id.match, ra.col] <- paste("unclassified", pre.ra)
    }
    
    ### aggregate
    # cm.taxa 1st col is "row.names", "ncol.samples" columns abundence, and length(col.ranks) columns rank
    data.ta <- cm.taxa[,c(2:(1+ncol.cm), ra.col)]
    taxa.assign <- aggregate(as.formula(paste(". ~", ra)), data=data.ta, FUN=sum)

    # move "unclassified ???" to last
    taxa.assign <- ComMA::mvRowsToLast(taxa.assign, ra, "unclassified")
    # move "unclassified phylum" to last
    if (!is.na(pre.ra)) 
      taxa.assign <- ComMA::mvRowsToLast(taxa.assign, ra, paste0("^unclassified ", pre.ra, "$"))
    # move "unclassified" to last
    taxa.assign <- ComMA::mvRowsToLast(taxa.assign, ra, "^unclassified$")
    
    ta.list[[ra]] <- taxa.assign
    pre.ra.col <- ra.col
    pre.ra <- ra
  }
  return(ta.list)
}

getRanks <- function() {
  ranks <- c("superkingdom", "kingdom", "phylum", "class", "order", "family", "genus", "species")
}

