# OPTIMAL NUMBER OF CLUSTERS  
# http://enterotype.embl.de/enterotypes_tutorial.sanger.R
#
# Author: Walter Xie
# Accessed on 23 Nov 2015
#
#install.packages("cluster")
#install.packages("clusterSim")
#library(cluster)
#library(clusterSim)
#library(ade4)
#library(ggplot2)
#library(ellipse)


#' @name enterotypes
#' @title Enterotypes
#'
#' @description The pipeline built for enterotypes 
#' \url{http://enterotype.embl.de}.
#' 
#' @details 
#' \code{enterotypes} is the pipeline summarised from 
#' \url{http://enterotype.embl.de/enterotypes_tutorial.sanger.R}.
#' The list of other functions below are the components to form 
#' this pipeline. 
#'  
#' @keywords enterotypes
#' @export
#' @examples 
#' enterotypes(taxa.assign, n.max=20, fig.path="figures", percent=0)
#'
#' @rdname enterotypes
enterotypes <- function(taxa.assign, n.max=20, k=NULL, fig.path=NULL, percent=0.01, verbose=TRUE, ...) {
  abun.dist.matrix <- getAbundanceDist(taxa.assign)
  #nrow(abun.dist.matrix);ncol(abun.dist.matrix)
  #colSums(abun.dist.matrix)
  jsd.dist <- getJSD(abun.dist.matrix)
  nclusters <- getClusters(abun.dist.matrix, jsd.dist, n.max=n.max, fig.path=fig.path)
  data.cluster <- getDataCluster(jsd.dist, k=k, measurements=nclusters, validate=TRUE, verbose=verbose)
  
  plotEnterotypes(abun.dist.matrix, jsd.dist, data.cluster, fig.path=fig.path, percent=percent)
}

#' @param taxa.assign The data frame of taxonomic assignments with abudence
#' at the \code{rank}, where rownames are taxonomy at that rank, 
#' and columns are the sample names. It can be 
#' one element of the list generated by \code{\link{assignTaxaByRank}}. 
#' @keywords enterotypes
#' @export
#' @examples 
#' abun.dist.matrix <- getAbundanceDist(taxa.assign)
#'
#' @rdname enterotypes
getAbundanceDist <- function(taxa.assign) {
  taxa.assign.prop <- prop.table(as.matrix(taxa.assign), 2)
}

#' @details 
#' \code{getJSD} return a distance \code{\link{dist}} object 
#' calculated by Jensen-Shannon divergence (JSD) metric.
#'  
#' @param abun.dist.matrix The matrix of normalized probability distributions 
#' of the abundance matrix, also called abundance distributions. 
#' @keywords enterotypes
#' @export
#' @examples 
#' jsd.dist <- getJSD(abun.dist.matrix)
#'
#' @rdname enterotypes
getJSD <- function(abun.dist.matrix) {
  #nrow(abun.dist.matrix);ncol(abun.dist.matrix)
  #colSums(abun.dist.matrix)
  jsd.dist=dist.JSD(abun.dist.matrix)
  return(jsd.dist)
}

#' @details 
#' \code{getClusters} return the Calinski-Harabasz (CH) Index 
#' for choosig a number of clusters from 2 to \code{n.max}.
#'  
#' @param jsd.dist A distance \code{\link{dist}} object 
#' calculated by Jensen-Shannon divergence (JSD) metric.
#' @param n.max The number of clusters. Default to 20.
#' @param fig.path The folder path to save figures. If NULL, 
#' the default, do not plot the figure.
#' @keywords enterotypes
#' @export
#' @examples 
#' nclusters <- getClusters(abun.dist.matrix, jsd.dist)
#'
#' @rdname enterotypes
getClusters <- function(abun.dist.matrix, jsd.dist, n.max=20, fig.path=NULL, ...) {
  nclusters=run.pam.cl(abun.dist.matrix, jsd.dist, n.max)
  if (! is.null(fig.path))
    plotOptClusters(fig.path, nclusters, n.max)
  return(nclusters)
}

#' @details 
#' \code{getDataCluster} return the optimised or selected solution having 
#' \code{k} clusters.
#'  
#' @param k The number of clusters chosen for the optimised solution.
#' If NULL, the defult, it will take the number of clusters having 
#' the largest CH Index. 
#' @param measurements The vector of measurements, such as 
#' Calinski-Harabasz (CH) Index, to find the optimised solution.
#' @param validate Logical if it needs to validate. Default to TRUE.
#' @keywords enterotypes
#' @export
#' @examples 
#' data.cluster <- getDataCluster(jsd.dist, measurements=nclusters)
#'
#' @rdname enterotypes
getDataCluster <- function(jsd.dist, k=NULL, measurements=NULL, validate=TRUE, verbose=TRUE) {
  if (is.null(k)) {
    if (is.null(measurements))
      stop("Please provide the measurements, such as CH Index, to find the optimised solution !")
    k=match(max(measurements[!is.na(measurements)]), measurements)
    cat("The optimised solution is ", k, " clusters.\n")
  }
  
  data.cluster=pam.clustering(jsd.dist, k)
  attr(data.cluster, "k") <- k
  if (verbose) {
    print(pam.clustering(jsd.dist, k, as.vector=F))
  }
    
  #nclusters = index.G1(t(data), data.cluster, d = data.dist, centrotypes = "medoids")
  if (validate)
    validateCluster(data.cluster, jsd.dist)
  return(data.cluster)
}

#' @details 
#' \code{plotEnterotypes} is a mixed function to plot clusters, 
#' BCA \code{\link{bca}} and PCoA \code{\link{dudi.pco}}
#' from the optimised or selected solution.
#' 
#' Between-class analysis (BCA) was performed to support the 
#' clustering and identify the drivers for the enterotypes.
#' It is only available when \code{k} > 2.
#'  
#' @param percent The percentage threshold to remove the noise 
#' (ie. low abundant genera). Prior to the analysis. 
#' Default to 0.
#' @param addLabel Logical if add labels of points. Default to TRUE.
#' @keywords enterotypes
#' @export
#' @examples 
#' data.cluster <- getClusters(jsd.dist)
#'
#' @rdname enterotypes
plotEnterotypes <- function(data, data.dist, data.cluster, fig.path, attr.data, percent=0, 
                            addLabel=TRUE, text.colour.id=NULL, verbose=TRUE, ...) {
  attr.data.cluster <- attributes(data.cluster)
  k <- attr.data.cluster$k
  
  if (percent > 0)
    data=noise.removal(data, percent)
  
  ComMA::plotClusterAbundence(data, data.cluster, fig.path=fig.path)
  
  require(ade4)
  if (k > 2) {
    #Between-class analysis (BCA) was performed to support the clustering and identify the drivers for the enterotypes. 
    obs.pca=dudi.pca(data.frame(t(data)), scannf=F, nf=10)
    obs.bet=bca(obs.pca, fac=as.factor(data.cluster), scannf=F, nf=k-1) 
    cat("\nplot", k, "clusters between-class analysis (BCA).\n") 
    
    bca.df <- as.data.frame(obs.bet$ls)
    colnames(bca.df)[1:2] <- c("PC1", "PC2")
    bca.df$cluster <- data.cluster
    bca.df$cluster <- factor(bca.df$cluster, levels = sort(unique(bca.df$cluster)))
    if (addLabel) {
      text.id="Row.names"
      bca.df$Row.names <- rownames(bca.df)
    } else {
      text.id=NULL
    }
    #  bca.df$species <- paste(sapply(strsplit(rownames(bca.df), "_"), "[[", 1), sapply(strsplit(rownames(bca.df), "_"), "[[", 2), sep=".")
    
    p <- ComMA::ggScatterPlot(bca.df, x.id="PC1", y.id="PC2", colour.id="cluster", ellipsed.id="cluster",
                              text.id=text.id, title="Between Class Analysis", palette="Set1",
                              xintercept=0, yintercept=0, verbose=verbose, ...)
    gt <- unclip.ggplot(p)  
    pdf.gtable(gt, fig.path=file.path(fig.path, paste0("enterotypes-between-class-",k,".pdf")), width=8, height=8)  
    #plotScatterEllipse(as.data.frame(obs.bet$ls, drop=FALSE), data.cluster, "Between class analysis", 
    #                   file.path(fig.path, paste0("enterotypes-between-class-",k,".pdf")), addLabel)
  }
  
  #principal coordinates analysis (PCoA) of a Euclidean distance matrix
  obs.pcoa=dudi.pco(data.dist, scannf=F, nf=3)
  cat("\nplot", k, "clusters principal coordinates analysis (PCoA).\n") 
  
  pcoa.df <- as.data.frame(obs.pcoa$li)
  colnames(pcoa.df)[1:3] <- c("PCo1", "PCo2", "PCo3")
  pcoa.df$cluster <- data.cluster
  pcoa.df$cluster <- factor(pcoa.df$cluster, levels = sort(unique(pcoa.df$cluster)))
  if (addLabel) {
    text.id="Row.names"
    if (! missing(attr.data)) {
      pcoa.df.merge <- merge(pcoa.df, attr.data, by = "row.names")
      
      if (nrow(pcoa.df.merge) != nrow(pcoa.df) || nrow(pcoa.df.merge) != nrow(attr.data)) 
        warning(paste("Some data points are missing after merge ! nrow(pcoa.df.merge) =", 
                      nrow(pcoa.df.merge), ", nrow(pcoa.df) =", nrow(pcoa.df), 
                      ", nrow(attr.data) =", nrow(attr.data) ))
    } else {
      pcoa.df$Row.names <- rownames(pcoa.df)
    }
  } else {
    text.id=NULL
  }
  
  p <- ComMA::ggScatterPlot(pcoa.df, x.id="PCo1", y.id="PCo2", colour.id="cluster", ellipsed.id="cluster",
                            text.id=text.id, text.colour.id=text.colour.id, palette="Set1",
                            title="Principal Coordinates Analysis",
                            xintercept=0, yintercept=0, verbose=verbose, ...)
  gt <- unclip.ggplot(p)  
  pdf.gtable(gt, fig.path=file.path(fig.path, paste0("enterotypes-principal-coordiante-",k,".pdf")), width=8, height=8) 
  #plotScatterEllipse(pcoa.df, data.cluster, "Principal coordinates analysis", 
  #                   file.path(fig.path, paste0("enterotypes-principal-coordiante-",k,".pdf")), addLabel)
}

plotOptClusters <- function(fig.path, nclusters, n.max=20) {
  # the optimal number of clusters
  pdf(file.path(fig.path, "optimal-clusters-JSD.pdf"), width=6, height=6)
  plot(nclusters, type="h", xlab="number of clusters", ylab="CH index",
       main=paste0("Optimal number of clusters (Jensen-Shannon divergence)"), xaxt="n")
  axis(1, at = seq(1, n.max, by = 2))
  invisible(dev.off())   
}

#' @details 
#' \code{plotClusterAbundence} return a list of \code{\link{ggplot2}} objects
#' for relative abundance distribution in each cluster.
#'  
#' @keywords enterotypes
#' @export
#' @examples 
#' p.list <- plotClusterAbundence(data, data.cluster)
#'
#' @rdname enterotypes
plotClusterAbundence <- function(data, data.cluster, fig.path=NA, cluster.colours=c(), min.median=0, 
                                 x.lab="", y.lab="Relative abundence", width=8, height=6) {
  attr.data.cluster <- attributes(data.cluster)
  k <- attr.data.cluster$k
  
  da.cl <- as.data.frame(cbind(t(data), cluster=data.cluster))
  require(reshape2)
  da.cl.melt <- melt(da.cl, id=c("cluster"))
  da.cl.melt <- da.cl.melt[da.cl.melt$value>0,]
  
  plot.list <- list()
  require(ggplot2)
  for (cl in sort(unique(data.cluster))) {
    gg <- da.cl.melt[da.cl.melt$cluster==cl,]
    cat("Cluster", cl, "samples:", paste(rownames(da.cl[da.cl$cluster==cl,]), collapse = ", "), ".\n") 
    gg$cluster <- paste0("cluster", cl)
    
    #if (min.median > 0)
      
    gg$variable <- reorder(gg$variable, gg$value, median, order=TRUE)
    
    if (length(cluster.colours) > 0 && cl <= length(cluster.colours))
      cl.col <- cluster.colours[cl]
    else
      cl.col <- NULL
    
    p <- ComMA::ggBoxWhiskersPlot(gg, x.id="variable", y.id="value", fill.id="cluster",
                                  palette=cl.col, scale.type="manual",
                                  x.lab=x.lab, y.lab=y.lab, title=paste("Cluster", cl), 
                                  x.text.angle=90, no.legend="fill")
    plot.list[[cl]] <- p
    if(!is.na(fig.path))
      pdf.ggplot(p, fig.path = file.path(fig.path, paste0("enterotype-",k,"-",cl,".pdf")), width=width, height=height)
  }
  return(plot.list)
}
# Jensen-Shannon divergence (JSD) (Endres & Schindelin, 2003)
# Kullback-Leibler divergence
dist.JSD <- function(inMatrix, pseudocount=0.000001, ...) {
  KLD <- function(x,y) sum(x *log(x/y))
  JSD<- function(x,y) sqrt(0.5 * KLD(x, (x+y)/2) + 0.5 * KLD(y, (x+y)/2))
  matrixColSize <- length(colnames(inMatrix))
  matrixRowSize <- length(rownames(inMatrix))
  colnames <- colnames(inMatrix)
  resultsMatrix <- matrix(0, matrixColSize, matrixColSize)
  
  inMatrix = apply(inMatrix,1:2,function(x) ifelse (x==0,pseudocount,x))
  
  for(i in 1:matrixColSize) {
    for(j in 1:matrixColSize) { 
      resultsMatrix[i,j]=JSD(as.vector(inMatrix[,i]),
                             as.vector(inMatrix[,j]))
    }
  }
  colnames -> colnames(resultsMatrix) -> rownames(resultsMatrix)
  as.dist(resultsMatrix)->resultsMatrix
  attr(resultsMatrix, "method") <- "dist"
  return(resultsMatrix) 
}
#data.dist=dist.JSD(data)

# Partitioning around medoids (PAM) clustering algorithm to cluster the abundance profiles. 
# PAM derives from the basic k-means algorithm, but has the advantage that it supports any 
# arbitrary distance measure and is more robust than k-means. It is a supervised procedure, 
# where the predetermined number of clusters is given as input to the procedure, which then 
# partitions the data into exactly that many clusters.
pam.clustering=function(x,k, as.vector=TRUE) { # x is a distance matrix and k the number of clusters
  require(cluster)
  cluster=pam(as.dist(x), k, diss=TRUE)
  if (as.vector) {
    return(as.vector(cluster$clustering))
  }
  return(cluster)
}
#data.cluster=pam.clustering(data.dist, k=3)

# n.max: max number of clusters to run
run.pam.cl=function(data, data.dist, n.max=20) {
  if (n.max < 2)
    stop("The max number of clusters must >= 2!")
  
  require(clusterSim)
  #nclusters = index.G1(t(data), data.cluster, d = data.dist, centrotypes = "medoids")
  nclusters=NULL
  for (k in 1:n.max) { 
    if (k==1) {
      nclusters[k]=NA 
    } else {
      data.cluster_temp=pam.clustering(data.dist, k)
      nclusters[k]=index.G1(t(data), data.cluster_temp, d=data.dist, centrotypes = "medoids")
    }
  }
  return(nclusters)
}
#nclusters=run.pam.cl(data, data.dist, n.max)

# Observations with a large s(i) (almost 1) are very well clustered,  
# a small s(i) (around 0) means that the observation lies between two clusters,  
# and observations with a negative s(i) are probably placed in the wrong cluster.
validateCluster <- function(data.cluster, data.dist) {
  require(cluster)
  obs.silhouette=mean(silhouette(data.cluster, data.dist)[,3])
  cat("obs.silhouette =", obs.silhouette, "\n") 
}

# advise to apply this function to data generated using 
# short sequencing technologes, like Illumina or Solid
noise.removal <- function(Matrix, percent=0.01){
  bigones <- rowSums(Matrix)*100/(sum(rowSums(Matrix))) > percent 
  Matrix_1 <- Matrix[bigones,]
  cat("percent = ", percent, ", remove", nrow(Matrix)-nrow(Matrix_1), "rows.\n")
  return(Matrix_1)
}

######### vegan cascadeKM ##########
plotCascadeKM <- function(fig.path, data, n.max) {
  library(vegan)
  
  ccas <- cascadeKM(t(data), 2, n.max)
  #ccas
  pdf(file.path(fig.path, paste0("optimal-clusters-cascadeKM.pdf")), width=6, height=6)
  plot(ccas, sortq=TRUE)
  invisible(dev.off()) 
  
  ccas <- cascadeKM(t(data), 2, 20, criterion = "ssi")
  pdf(file.path(fig.path, paste0("optimal-clusters-cascadeKM-ssi.pdf")), width=6, height=6)
  plot(ccas, sortq=TRUE)
  invisible(dev.off())
}

######### original plot fuction  ##########
plotEnterotypes.bak <- function(fig.path, data, data.dist, data.cluster, k, percent=0.01) {
  if (percent > 0)
    data=noise.removal(data, percent)
  
  require(ade4)
  ## plot 1
  obs.pca=dudi.pca(data.frame(t(data)), scannf=F, nf=10)
  obs.bet=bca(obs.pca, fac=as.factor(data.cluster), scannf=F, nf=k-1) 
  
  pdf(file.path(fig.path, "enterotypes-between-class.pdf"), width=6, height=6)
  #  dev.new()
  s.class(obs.bet$ls, fac=as.factor(data.cluster), grid=F,sub="Between-class analysis")
  invisible(dev.off()) 
  
  #plot 2
  obs.pcoa=dudi.pco(data.dist, scannf=F, nf=k)
  
  pdf(file.path(fig.path, "enterotypes-principal-coordiante.pdf"), width=6, height=6)
  #  dev.new()
  s.class(obs.pcoa$li, fac=as.factor(data.cluster), grid=F,sub="Principal coordiante analysis")
  invisible(dev.off())
}
